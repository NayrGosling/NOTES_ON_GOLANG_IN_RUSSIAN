# Миграция баз данных в Golang с PostgreSQL

## Введение

Миграция баз данных — это процесс управления изменениями структуры базы данных (схемы) в процессе разработки и эксплуатации приложения. В Go, при работе с PostgreSQL, миграции помогают автоматизировать создание, обновление и откат изменений таблиц, индексов, ограничений и других объектов базы данных. Это особенно важно для командного и долгосрочного развития приложений, чтобы обеспечить согласованность схемы между окружениями (разработка, тестирование, продакшен).

В этой лекции мы разберём:
- Что такое миграции и зачем они нужны.
- Основные инструменты для миграций в Go с PostgreSQL.
- Как реализовать миграции с использованием популярных библиотек.
- Преимущества и недостатки подходов.
- Практические примеры и рекомендации.

---

## 1. Что такое миграции баз данных?

Миграции — это набор инструкций (скриптов или кода), которые описывают изменения схемы базы данных, такие как:
- Создание или удаление таблиц.
- Добавление, изменение или удаление столбцов, индексов, ограничений (PK, FK, UNIQUE).
- Изменение данных (например, заполнение или преобразование).
- Откат изменений (rollback) при необходимости.

### Зачем нужны миграции?
- **Синхронизация схемы**: Обеспечение одинаковой структуры базы данных во всех окружениях.
- **Отслеживание изменений**: Ведение истории изменений схемы для командной работы.
- **Автоматизация**: Упрощение развертывания и обновления приложений.
- **Безопасность**: Минимизация ошибок при ручном изменении схемы.

---

## 2. Инструменты для миграций в Go с PostgreSQL

В Go существует несколько библиотек и инструментов для управления миграциями PostgreSQL. Рассмотрим самые популярные:

### 2.1. Golang Migrations (goose)
`goose` — это популярная библиотека для миграций, поддерживающая PostgreSQL, MySQL, SQLite и другие СУБД. Она использует SQL-скрипты или Go-функции для выполнения миграций.

#### Установка
```bash
go get github.com/pressly/goose/v3
```

#### Структура проекта
Создайте директорию для миграций, например `migrations/`, и добавьте SQL-файлы с суффиксами `_up.sql` (для применения) и `_down.sql` (для отката):

```
migrations/
├── 20240303120000_create_users_table.up.sql
└── 20240303120000_create_users_table.down.sql
```

#### Пример миграции (SQL)
`20240303120000_create_users_table.up.sql`:
```sql
CREATE TABLE users (
    id SERIAL PRIMARY KEY,
    name TEXT NOT NULL,
    email TEXT UNIQUE NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_users_email ON users(email);
```

`20240303120000_create_users_table.down.sql`:
```sql
DROP INDEX idx_users_email;
DROP TABLE users;
```

#### Использование в Go
```go
package main

import (
    "database/sql"
    "log"
    _ "github.com/lib/pq" // Драйвер для PostgreSQL
    "github.com/pressly/goose/v3"
)

func main() {
    db, err := sql.Open("postgres", "user=postgres password=secret dbname=mydb sslmode=disable")
    if err != nil {
        log.Fatal("Failed to connect to database:", err)
    }
    defer db.Close()

    if err := goose.SetDialect("postgres"); err != nil {
        log.Fatal("Failed to set dialect:", err)
    }

    // Применение всех миграций
    if err := goose.Up(db, "migrations"); err != nil {
        log.Fatal("Migration failed:", err)
    }
}
```

#### Команды `goose`
- `goose up` — применить все миграции.
- `goose down` — откатить последнюю миграцию.
- `goose status` — показать статус миграций.
- `goose create "create_users_table" sql` — создать новый файл миграции.

---

### 2.2. GORM Migrations
GORM — ORM для Go, который поддерживает встроенные миграции через метод `AutoMigrate`. Это более программный подход, чем использование SQL-скриптов.

#### Установка
```bash
go get gorm.io/gorm
go get gorm.io/driver/postgres
```

#### Пример миграции с GORM
```go
package main

import (
    "gorm.io/driver/postgres"
    "gorm.io/gorm"
    "log"
)

type User struct {
    ID        uint   `gorm:"primaryKey"`
    Name      string `gorm:"type:varchar(100);not null"`
    Email     string `gorm:"unique;type:varchar(100)"`
    CreatedAt time.Time
}

func main() {
    dsn := "host=localhost user=postgres password=secret dbname=mydb port=5432 sslmode=disable"
    db, err := gorm.Open(postgres.Open(dsn), &gorm.Config{})
    if err != nil {
        log.Fatal("Failed to connect to database:", err)
    }

    // Автоматическая миграция таблицы users
    if err := db.AutoMigrate(&User{}); err != nil {
        log.Fatal("Migration failed:", err)
    }
    log.Println("Database migrated successfully!")
}
```

#### Преимущества GORM Migrations
- Простота: Не нужно писать SQL-скрипты, миграции генерируются автоматически на основе моделей.
- Интеграция с ORM: Легко использовать вместе с другими функциями GORM (CRUD, ассоциации).
- Гибкость: Поддерживает кастомные миграции через `Migrator`.

#### Недостатки
- Меньшая контроль: `AutoMigrate` может не поддерживать сложные изменения (например, добавление индексов с условиями или сложные ограничения).
- Риски потери данных: При изменении структуры моделей GORM может удалить существующие таблицы или столбцы без предупреждения (если не настроено должным образом).
- Ограниченная трассировка: Трудно отслеживать историю изменений, как в `goose`.

---

### 2.3. Другие инструменты
- **migrate**: Ещё одна популярная библиотека для миграций, похожая на `goose`, но более лёгкая. Использует SQL-скрипты.
- **sql-migrate**: Поддерживает SQL-миграции и Go-код, интегрируется с `database/sql`.

---

## 3. Процесс миграции

### 3.1. Создание миграций
- Определите изменения схемы (например, добавление таблицы `users`).
- Создайте файл миграции с уникальным именем (например, `20240303120000_create_users_table.up.sql` и `.down.sql`).
- Используйте инструменты для генерации файлов (например, `goose create`).

### 3.2. Применение миграций
- Подключитесь к базе данных.
- Выполните команду для применения миграций (например, `goose up` или вызов `AutoMigrate` в GORM).

### 3.3. Откат миграций
- Используйте `goose down` для отката последней миграции или определите rollback-скрипты в `.down.sql`.
- В GORM откат вручную через SQL-запросы или кастомные функции.

### 3.4. Управление версиями
- Инструменты вроде `goose` создают таблицу (например, `goose_db_version`), чтобы отслеживать применённые миграции.
- Убедитесь, что миграции применяются последовательно и в правильном порядке.

---

## 4. Практический пример с `goose`

### Структура проекта
```
project/
├── main.go
├── migrations/
│   ├── 20240303120000_create_users_table.up.sql
│   └── 20240303120000_create_users_table.down.sql
```

#### `main.go`
```go
package main

import (
    "database/sql"
    "log"
    _ "github.com/lib/pq"
    "github.com/pressly/goose/v3"
)

func main() {
    db, err := sql.Open("postgres", "user=postgres password=secret dbname=mydb sslmode=disable")
    if err != nil {
        log.Fatal("Failed to connect to database:", err)
    }
    defer db.Close()

    if err := goose.SetDialect("postgres"); err != nil {
        log.Fatal("Failed to set dialect:", err)
    }

    // Применение миграций
    if err := goose.Up(db, "migrations"); err != nil {
        log.Fatal("Migration failed:", err)
    }
    log.Println("Migrations applied successfully!")
}
```

#### `20240303120000_create_users_table.up.sql`
```sql
CREATE TABLE users (
    id SERIAL PRIMARY KEY,
    name TEXT NOT NULL,
    email TEXT UNIQUE NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_users_email ON users(email);
```

#### `20240303120000_create_users_table.down.sql`
```sql
DROP INDEX idx_users_email;
DROP TABLE users;
```

#### Запуск
1. Убедитесь, что PostgreSQL запущен и доступен.
2. Выполните `go run main.go` для применения миграций.

---

## 5. Преимущества и недостатки подходов

### 5.1. `goose` и SQL-миграции
#### Преимущества
- Полный контроль над SQL: Можно писать сложные скрипты с условиями, триггерами, функциями.
- Трассировка изменений: Легко отслеживать историю через файлы миграций.
- Гибкость: Подходит для любых СУБД и сложных сценариев.

#### Недостатки
- Требует знаний SQL: Нужно вручную писать и поддерживать скрипты.
- Больше кода: SQL-скрипты увеличивают объём проекта.
- Риск ошибок: Неправильный `down` может привести к потере данных.

### 5.2. GORM `AutoMigrate`
#### Преимущества
- Простота: Не требует написания SQL, миграции генерируются автоматически.
- Интеграция: Легко использовать с ORM для CRUD.
- Быстрая разработка: Подходит для небольших проектов или прототипов.

#### Недостатки
- Ограниченная функциональность: Не поддерживает сложные изменения (например, добавление индексов с условиями).
- Риск потери данных: Может удалить таблицы или столбцы без предупреждения.
- Трудно отслеживать историю: Нет явной версии миграций.

---

## 6. Рекомендации по миграциям

1. **Выберите подходящий инструмент**:
   - Используйте `goose` или `migrate` для больших проектов с SQL-скриптами.
   - Применяйте GORM `AutoMigrate` для простых проектов с ORM.

2. **Отслеживайте изменения**:
   - Храните миграции в системе контроля версий (Git) для прозрачности и совместной работы.

3. **Тестируйте миграции**:
   - Проверяйте миграции на тестовых базах перед применением на продакшене.
   - Убедитесь, что `down` корректно откатывает изменения.

4. **Обеспечьте безопасность**:
   - Используйте транзакции для миграций, чтобы предотвратить частичное выполнение.
   - Избегайте прямых изменений данных в миграциях, если это не критично.

5. **Управляйте версиями**:
   - Используйте уникальные названия миграций с временными метками (например, `20240303120000_`).
   - Поддерживайте таблицу версий (например, `goose_db_version`) для отслеживания статуса.

6. **Документируйте**:
   - Описывайте цель каждой миграции в комментариях или README.

---

## 7. Заключение

Миграции баз данных в Go с PostgreSQL — важный аспект разработки, обеспечивающий согласованность и автоматизацию изменений схемы. Инструменты вроде `goose` и GORM предоставляют разные подходы: SQL-скрипты для полного контроля и ORM-миграции для простоты. Выбор зависит от размера проекта, сложности схемы и требований команды. Следуйте рекомендациям, чтобы минимизировать риски и повысить надёжность вашего приложения.