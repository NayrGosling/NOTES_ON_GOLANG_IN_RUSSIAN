# SQL-транзакции: Лекция для разработчиков

## Введение

**Транзакции** в SQL — это фундаментальный механизм для обеспечения согласованности данных в базе данных при выполнении нескольких операций. Они позволяют группировать операции в единое целое, гарантируя, что либо все операции будут успешно выполнены, либо ни одна из них не применится. Для Senior-разработчиков понимание транзакций выходит за рамки базовых `BEGIN` и `COMMIT` — это про управление сложными сценариями, оптимизацию производительности и обработку ошибок в реальных системах.

В этой лекции мы разберём:
- Основы транзакций и их свойства (ACID).
- Реализацию в SQL и интеграцию с Go.
- Уровни изоляции и их влияние на производительность.
- Лучшие практики и типичные ошибки.

## Что такое транзакция?

Транзакция — это последовательность операций с базой данных, которая рассматривается как единое целое. Если одна операция завершается неудачно, изменения откатываются, чтобы сохранить данные в согласованном состоянии.

### Пример сценария

Перевод денег между счетами:
1. Снять $100 с аккаунта A.
2. Зачислить $100 на аккаунт B.

Если вторая операция не удастся (например, из-за сбоя), деньги не должны пропасть с аккаунта A. Транзакция решает эту проблему.

---

## Свойства транзакций (ACID)

Транзакции в реляционных базах данных (PostgreSQL, MySQL и др.) следуют свойствам ACID:

1. **Atomicity (Атомарность)**:
   - Все операции в транзакции выполняются полностью или не выполняются вовсе.
   - Пример: Если зачисление денег не удалось, списание откатывается.

2. **Consistency (Согласованность)**:
   - Транзакция переводит базу данных из одного согласованного состояния в другое.
   - Ограничения (constraints), такие как `NOT NULL` или `FOREIGN KEY`, соблюдаются.

3. **Isolation (Изоляция)**:
   - Транзакции изолированы друг от друга. Частично выполненные изменения не видны другим транзакциям до завершения.
   - Уровень изоляции влияет на это свойство (см. ниже).

4. **Durability (Долговечность)**:
   - После завершения транзакции (COMMIT) изменения сохраняются даже при сбое системы (например, через WAL — Write-Ahead Logging).

---

## Основные команды SQL для транзакций

- `BEGIN` или `START TRANSACTION`: Начать транзакцию.
- `COMMIT`: Применить изменения.
- `ROLLBACK`: Откатить изменения.
- `SAVEPOINT`: Установить точку сохранения внутри транзакции для частичного отката.

### Пример на SQL

```sql
BEGIN;

UPDATE accounts SET balance = balance - 100 WHERE account_id = 'A';
UPDATE accounts SET balance = balance + 100 WHERE account_id = 'B';

COMMIT;
```
Если что-то пойдёт не так (например, ошибка при обновлении второго счета), можно выполнить:
`ROLLBACK;`

## Уровни изоляции транзакций
Изоляция определяет, как транзакции взаимодействуют друг с другом. Неправильный уровень изоляции может привести к аномалиям, таким как "грязное чтение" или "фантомные строки". ANSI SQL определяет четыре уровня изоляции:

1. Read Uncommitted (Чтение неподтверждённых данных):
- Транзакция видит неподтверждённые изменения другой транзакции.
- Проблема: "Грязное чтение" (dirty read).
- Редко используется из-за низкой надёжности.
2. Read Committed (Чтение подтверждённых данных):
- Транзакция видит только подтверждённые данные, но возможны изменения между чтениями.
- Проблема: "Неповторяемое чтение" (non-repeatable read).
- Дефолт во многих СУБД (например, PostgreSQL).
3. Repeatable Read (Повторяемое чтение):
- Данные, прочитанные в транзакции, не меняются до её завершения.
- Проблема: "Фантомные строки" (phantom read).
- Дефолт в MySQL (InnoDB).
4. Serializable (Сериализуемость):
- Полная изоляция. Транзакции выполняются так, как если бы они шли последовательно.
- Нет аномалий, но ниже производительность из-за блокировок.
  
### Пример аномалии
```sql
-- Транзакция 1
BEGIN;
UPDATE accounts SET balance = balance - 100 WHERE account_id = 'A';

-- Транзакция 2 (Read Uncommitted)
SELECT balance FROM accounts WHERE account_id = 'A'; -- Увидит balance - 100, хотя COMMIT ещё не был

-- Транзакция 1
ROLLBACK;

-- Транзакция 2 получила "грязные" данные
```
## Реализация транзакций в Go
Для работы с транзакциями в Go используем пакет database/sql. Пример с PostgreSQL:

Пример: Перевод денег
```go
package main

import (
	"database/sql"
	"fmt"
	"log"

	_ "github.com/lib/pq"
)

const (
	host     = "localhost"
	port     = 5432
	user     = "postgres"
	password = "password"
	dbname   = "testdb"
)

func main() {
	connStr := fmt.Sprintf("host=%s port=%d user=%s password=%s dbname=%s sslmode=disable",
		host, port, user, password, dbname)
	db, err := sql.Open("postgres", connStr)
	if err != nil {
		log.Fatal(err)
	}
	defer db.Close()

	err = transferMoney(db, "A", "B", 100)
	if err != nil {
		log.Println("Transfer failed:", err)
	} else {
		fmt.Println("Transfer succeeded")
	}
}

func transferMoney(db *sql.DB, from, to string, amount int) error {
	// Начинаем транзакцию
	tx, err := db.Begin()
	if err != nil {
		return err
	}

	// Откладываем откат на случай ошибки
	defer func() {
		if err != nil {
			tx.Rollback()
			return
		}
		err = tx.Commit()
	}()

	// Проверяем баланс
	var balance int
	err = tx.QueryRow("SELECT balance FROM accounts WHERE account_id = $1 FOR UPDATE", from).Scan(&balance)
	if err != nil {
		return err
	}
	if balance < amount {
		return fmt.Errorf("insufficient funds")
	}

	// Снимаем деньги
	_, err = tx.Exec("UPDATE accounts SET balance = balance - $1 WHERE account_id = $2", amount, from)
	if err != nil {
		return err
	}

	// Зачисляем деньги
	_, err = tx.Exec("UPDATE accounts SET balance = balance + $1 WHERE account_id = $2", amount, to)
	if err != nil {
		return err
	}

	return nil
}
```

## Уровни изоляции в Go
Установка уровня изоляции в Go:
```go
tx, err := db.BeginTx(context.Background(), &sql.TxOptions{
	Isolation: sql.LevelSerializable,
})
```
### Поддерживаемые уровни:
- sql.LevelReadUncommitted
- sql.LevelReadCommitted
- sql.LevelRepeatableRead
- sql.LevelSerializable
  
## Лучшие практики
1. Минимизируйте время транзакции:
  - Выполняйте только необходимые операции внутри транзакции, чтобы уменьшить блокировки.
2. Используйте правильный уровень изоляции:
  - Read Committed — для большинства случаев.
  - Serializable — для критически важных операций.
3. Обрабатывайте ошибки:
  - Всегда проверяйте результат Commit и готовьтесь к откату.
4. Используйте SAVEPOINT для сложных транзакций:
```sql
BEGIN;
INSERT INTO orders (id, total) VALUES (1, 100);
SAVEPOINT order_savepoint;
INSERT INTO order_items (order_id, item) VALUES (1, 'item1');
ROLLBACK TO SAVEPOINT order_savepoint;
COMMIT;
```
5. Блокируйте только нужное:
  - Используйте FOR UPDATE или FOR SHARE для точечных блокировок.
6. Тестируйте параллелизм:
  - Симулируйте конкурентные транзакции для выявления дедлоков.
    
## Типичные ошибки
1. Долгие транзакции:
  - Выполнение тяжёлых запросов или внешних вызовов внутри транзакции увеличивает риск дедлоков.
2. Игнорирование дедлоков:
  - Пример: Две транзакции блокируют строки в разном порядке.
  - Решение: Упорядочить операции или использовать RETRY логику.
3. Неправильный уровень изоляции:
  - Использование Read Uncommitted там, где нужна согласованность.
4. Потеря ошибок:
  - Не проверять результат Commit:
```go
err = tx.Commit()
if err != nil {
    log.Fatal("Commit failed:", err)
}
```
5. Забытый откат:
  - Не вызывать Rollback при ошибке вручную (используйте defer).

## Масштабируемость и производительность
1. Оптимизация блокировок:
  - Минимизируйте количество блокировок и их длительность.
2. Репликация:
  - Используйте чтение с реплик, но учитывайте задержки (eventual consistency).
3. Шардирование:
  - Разделяйте данные для уменьшения конкуренции.
4. Мониторинг:
  - Отслеживайте дедлоки и время выполнения транзакций (например, через pg_stat_activity в PostgreSQL).
    
## Заключение
SQL-транзакции — это не просто инструмент для сохранения согласованности, а мощный механизм, требующий глубокого понимания для эффективного использования в продакшене. Senior-разработчик должен:

Уметь выбирать правильный уровень изоляции для задачи.
Проектировать транзакции с учётом производительности и масштабируемости.
Предвидеть и обрабатывать аномалии параллелизма.
Go с database/sql предоставляет гибкость для работы с транзакциями, но требует дисциплины в обработке ошибок и управлении ресурсами. Начинайте с простых транзакций и оптимизируйте по мере роста сложности системы.

Совет: Всегда тестируйте транзакции под нагрузкой и с конкурентным доступом — только так можно выявить скрытые проблемы.
