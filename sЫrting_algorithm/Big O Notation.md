# Асимптотическая сложность и нотация O()

## Введение

В анализе алгоритмов важнейшую роль играет оценка их эффективности. Основной метод оценки — это асимптотический анализ, который показывает, как ведет себя алгоритм при увеличении размера входных данных.

**O-большое (Big O)** — это способ выражения верхней границы сложности алгоритма в худшем случае. Оно позволяет понять, как изменяется время выполнения или потребление памяти при увеличении входных данных.

---

## Основные виды сложности

### O(1) — Константная сложность

Алгоритм работает за фиксированное время, независимо от размера входных данных.

**Пример:**
```go
func GetFirstElement(arr []int) int {
    return arr[0]
}
```
✅ Время выполнения **не зависит** от длины массива.

---

### O(log n) — Логарифмическая сложность

Производительность алгоритма растет логарифмически, что означает, что увеличение входных данных вдвое приводит к увеличению количества операций на незначительное число.

**Пример:** Бинарный поиск
```go
func BinarySearch(arr []int, target int) int {
    left, right := 0, len(arr)-1
    for left <= right {
        mid := left + (right-left)/2
        if arr[mid] == target {
            return mid
        } else if arr[mid] < target {
            left = mid + 1
        } else {
            right = mid - 1
        }
    }
    return -1
}
```
✅ Количество операций сокращается вдвое с каждым шагом.

---

### O(n) — Линейная сложность

Время выполнения линейно зависит от размера входных данных.

**Пример:** Линейный поиск
```go
func LinearSearch(arr []int, target int) int {
    for i, val := range arr {
        if val == target {
            return i
        }
    }
    return -1
}
```
✅ Если в массиве 1000 элементов, в худшем случае потребуется 1000 сравнений.

---

### O(n log n) — Квазилинейная сложность

Типично встречается в алгоритмах сортировки, таких как быстрая и сортировка слиянием.

**Пример:**
```go
func MergeSort(arr []int) []int {
    if len(arr) < 2 {
        return arr
    }
    mid := len(arr) / 2
    left := MergeSort(arr[:mid])
    right := MergeSort(arr[mid:])
    return merge(left, right)
}
```
✅ Разделение массива занимает O(log n), а слияние O(n), итого O(n log n).

---

### O(n²) — Квадратичная сложность

Время выполнения растет пропорционально квадрату размера входных данных.

**Пример:** Пузырьковая сортировка
```go
func BubbleSort(arr []int) {
    n := len(arr)
    for i := 0; i < n-1; i++ {
        for j := 0; j < n-i-1; j++ {
            if arr[j] > arr[j+1] {
                arr[j], arr[j+1] = arr[j+1], arr[j]
            }
        }
    }
}
```
✅ При размере массива 1000 потребуется **1 000 000** операций.

---

### O(2^n) — Экспоненциальная сложность

Каждое увеличение входных данных увеличивает число операций в 2 раза.

**Пример:** Решение задачи о Ханойских башнях
```go
func Hanoi(n int, from, to, aux string) {
    if n == 1 {
        fmt.Printf("Move disk 1 from %s to %s\n", from, to)
        return
    }
    Hanoi(n-1, from, aux, to)
    fmt.Printf("Move disk %d from %s to %s\n", n, from, to)
    Hanoi(n-1, aux, to, from)
}
```
✅ Количество шагов удваивается с каждым новым диском.

---

## Итоговая таблица сложностей

| Нотация | Название | Пример |
|---------|---------|--------|
| O(1)    | Константная | Доступ к элементу массива |
| O(log n)| Логарифмическая | Бинарный поиск |
| O(n)    | Линейная | Линейный поиск |
| O(n log n) | Квазилинейная | Быстрая сортировка |
| O(n²)   | Квадратичная | Пузырьковая сортировка |
| O(2^n)  | Экспоненциальная | Задача о Ханойских башнях |

---

## Заключение

Анализ сложности алгоритмов помогает выбирать наиболее эффективные решения. На практике, если можно избежать O(n²) или O(2^n), лучше заменить их на более быстрые варианты, такие как O(n log n) или O(n).

