# Алгоритмы сортировки

## Введение

Сортировка — это процесс упорядочивания элементов в списке или массиве по возрастанию или убыванию. Алгоритмы сортировки играют ключевую роль в компьютерных науках, поскольку они используются во многих приложениях, от баз данных до обработки изображений.

Алгоритмы сортировки можно классифицировать по нескольким критериям:
- **Временная сложность** (лучший, средний и худший случай)
- **Использование дополнительной памяти** (in-place или нет)
- **Стабильность** (сохранение порядка равных элементов)
- **Метод сортировки** (обмен, вставки, слияние и др.)

Рассмотрим основные алгоритмы сортировки, их реализацию и характеристики.

---

## 1. Пузырьковая сортировка (Bubble Sort)

### Описание
Этот алгоритм проходит по массиву, сравнивает соседние элементы и меняет их местами, если они находятся в неправильном порядке. Процесс повторяется до тех пор, пока массив не будет отсортирован.

### Реализация
```go
func BubbleSort(arr []int) {
    n := len(arr)
    for i := 0; i < n-1; i++ {
        swapped := false
        for j := 0; j < n-i-1; j++ {
            if arr[j] > arr[j+1] {
                arr[j], arr[j+1] = arr[j+1], arr[j]
                swapped = true
            }
        }
        if !swapped {
            break
        }
    }
}
```

### Характеристики
- **Временная сложность:** O(n²)
- **Дополнительная память:** O(1)
- **Стабильность:** Да
- **Применение:** Используется редко, так как медленный

---

## 2. Сортировка выбором (Selection Sort)

### Описание
На каждом шаге находим минимальный элемент в неотсортированной части массива и меняем его с первым элементом этой части.

### Реализация
```go
func SelectionSort(arr []int) {
    n := len(arr)
    for i := 0; i < n-1; i++ {
        minIndex := i
        for j := i + 1; j < n; j++ {
            if arr[j] < arr[minIndex] {
                minIndex = j
            }
        }
        arr[i], arr[minIndex] = arr[minIndex], arr[i]
    }
}
```

### Характеристики
- **Временная сложность:** O(n²)
- **Дополнительная память:** O(1)
- **Стабильность:** Нет
- **Применение:** Подходит для небольших массивов

---

## 3. Сортировка вставками (Insertion Sort)

### Описание
Берем элементы по одному и вставляем их в правильную позицию в отсортированной части массива.

### Реализация
```go
func InsertionSort(arr []int) {
    n := len(arr)
    for i := 1; i < n; i++ {
        key := arr[i]
        j := i - 1
        for j >= 0 && arr[j] > key {
            arr[j+1] = arr[j]
            j--
        }
        arr[j+1] = key
    }
}
```

### Характеристики
- **Временная сложность:** O(n²), но O(n) в лучшем случае
- **Дополнительная память:** O(1)
- **Стабильность:** Да
- **Применение:** Хорош для небольших массивов или почти отсортированных данных

---

## 4. Быстрая сортировка (Quick Sort)

### Описание
Выбирается опорный элемент (pivot), затем массив делится на две части: элементы меньше pivot и больше pivot. Затем сортируем эти части рекурсивно.

### Реализация
```go
func QuickSort(arr []int) []int {
    if len(arr) < 2 {
        return arr
    }
    pivot := arr[len(arr)/2]
    left := []int{}
    right := []int{}
    equal := []int{}
    
    for _, num := range arr {
        if num < pivot {
            left = append(left, num)
        } else if num > pivot {
            right = append(right, num)
        } else {
            equal = append(equal, num)
        }
    }
    
    return append(append(QuickSort(left), equal...), QuickSort(right)...)
}
```

### Характеристики
- **Временная сложность:** O(n log n), но O(n²) в худшем случае
- **Дополнительная память:** O(log n) (из-за рекурсии)
- **Стабильность:** Нет
- **Применение:** Один из самых быстрых и широко используемых алгоритмов

---

## 5. Сортировка слиянием (Merge Sort)

### Описание
Рекурсивно делим массив пополам, сортируем каждую часть и объединяем обратно.

### Реализация
```go
func MergeSort(arr []int) []int {
    if len(arr) < 2 {
        return arr
    }
    mid := len(arr) / 2
    left := MergeSort(arr[:mid])
    right := MergeSort(arr[mid:])
    return merge(left, right)
}

func merge(left, right []int) []int {
    result := []int{}
    i, j := 0, 0
    for i < len(left) && j < len(right) {
        if left[i] < right[j] {
            result = append(result, left[i])
            i++
        } else {
            result = append(result, right[j])
            j++
        }
    }
    return append(result, append(left[i:], right[j:]...)...)
}
```

### Характеристики
- **Временная сложность:** O(n log n)
- **Дополнительная память:** O(n)
- **Стабильность:** Да
- **Применение:** Хорош для больших массивов

---

## Вывод
Выбор алгоритма сортировки зависит от задачи:
- **Для небольших массивов**: Сортировка вставками или выбором
- **Для больших массивов**: Быстрая сортировка или сортировка слиянием
- **Для стабильной сортировки**: Сортировка слиянием

Алгоритмы сортировки являются основой многих приложений, и их понимание поможет в написании эффективного кода.

