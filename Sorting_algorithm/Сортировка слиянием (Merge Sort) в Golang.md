# Сортировка слиянием (Merge Sort) в Golang

## Введение

Сортировка слиянием (Merge Sort) — это эффективный алгоритм сортировки, основанный на принципе "разделяй и властвуй" (divide and conquer). Он делит массив на две половины, рекурсивно сортирует их, а затем сливает (merge) отсортированные части в один отсортированный массив. Merge Sort известен своей стабильностью и предсказуемой производительностью, что делает его подходящим для больших данных и ситуаций, где важна стабильность.

В этой лекции мы разберём:
- Как работает сортировка слиянием.
- Реализацию алгоритма в Go.
- Преимущества и недостатки.
- Сравнение с другими алгоритмами сортировки.
- Практические примеры и рекомендации по использованию в Go.

---

## 1. Как работает сортировка слиянием?

### Принцип работы
1. **Разделение (divide)**: Делим входной массив на две равные (или почти равные) половины, пока подмассивы не станут единичными (содержат один элемент или пусты).
2. **Слияние (merge)**: Сливаем (объединяем) отсортированные подмассивы в один отсортированный массив, сравнивая элементы и размещая их в правильном порядке.
3. **Рекурсия**: Процесс повторяется рекурсивно для каждой половины, пока весь массив не станет отсортированным.

### Сложность алгоритма
- **Временная сложность**:
  - Худший случай (`O(n log n)`): Для любого порядка данных, так как алгоритм всегда выполняет одинаковое количество операций деления и слияния.
  - Лучший случай (`O(n log n)`): Когда массив уже отсортирован, но слияние всё равно требуется.
  - Средний случай (`O(n log n)`): Для случайных данных.
- **Пространственная сложность**: `O(n)` — требуется дополнительная память для временного массива при слиянии, плюс `O(log n)` для рекурсивного стека вызовов.

---

## 2. Реализация сортировки слиянием в Go

### 2.1. Базовая реализация
Вот простая реализация сортировки слиянием в Go для среза целых чисел (`[]int`):

```go
package main

import "fmt"

func mergeSort(arr []int) []int {
    // Создаём копию, чтобы не изменять исходный массив
    result := make([]int, len(arr))
    copy(result, arr)
    mergeSortRange(result, 0, len(result)-1)
    return result
}

func mergeSortRange(arr []int, low, high int) {
    if low < high {
        mid := (low + high) / 2
        // Рекурсивно сортируем левую и правую части
        mergeSortRange(arr, low, mid)
        mergeSortRange(arr, mid+1, high)
        // Сливаем отсортированные части
        merge(arr, low, mid, high)
    }
}

func merge(arr []int, low, mid, high int) {
    // Создаём временные срезы для левой и правой частей
    left := make([]int, mid-low+1)
    right := make([]int, high-mid)

    // Копируем данные в временные срезы
    for i := 0; i < len(left); i++ {
        left[i] = arr[low+i]
    }
    for j := 0; j < len(right); j++ {
        right[j] = arr[mid+1+j]
    }

    // Сливаем отсортированные части обратно в arr
    i := 0 // Индекс для левой части
    j := 0 // Индекс для правой части
    k := low // Индекс для основного массива

    for i < len(left) && j < len(right) {
        if left[i] <= right[j] {
            arr[k] = left[i]
            i++
        } else {
            arr[k] = right[j]
            j++
        }
        k++
    }

    // Копируем оставшиеся элементы левой части, если они есть
    for i < len(left) {
        arr[k] = left[i]
        i++
        k++
    }

    // Копируем оставшиеся элементы правой части, если они есть
    for j < len(right) {
        arr[k] = right[j]
        j++
        k++
    }
}

func main() {
    // Пример массива
    arr := []int{64, 34, 25, 12, 22, 11, 90}
    fmt.Println("Исходный массив:", arr)

    sorted := mergeSort(arr)
    fmt.Println("Отсортированный массив:", sorted)
}
```

**Вывод:**
```
Исходный массив: [64 34 25 12 22 11 90]
Отсортированный массив: [11 12 22 25 34 64 90]
```

#### Разъяснение
- Функция `mergeSort` создаёт копию массива и вызывает рекурсивную функцию `mergeSortRange` для сортировки всего диапазона.
- `mergeSortRange` рекурсивно делит массив на две половины до тех пор, пока подмассивы не станут единичными, затем вызывает `merge` для их слияния.
- `merge` создаёт временные срезы для левой и правой частей, сортирует их, сравнивая элементы, и объединяет в отсортированный подмассив.

---

### 2.2. Пошаговый процесс для массива `[64, 34, 25, 12, 22, 11, 90]`

1. **Разделение**:
   - Делим массив на `[64, 34, 25, 12]` и `[22, 11, 90]`.
   - Рекурсивно делим каждую половину, пока не получим единичные элементы: `[64], [34], [25], [12]` и `[22], [11], [90]`.

2. **Слияние**:
   - Сливаем `[64]` и `[34]` → `[34, 64]`.
   - Сливаем `[25]` и `[12]` → `[12, 25]`.
   - Сливаем `[34, 64]` и `[12, 25]` → `[12, 25, 34, 64]`.
   - Аналогично для правой половины: `[22]` и `[11]` → `[11, 22]`, затем `[11, 22]` и `[90]` → `[11, 22, 90]`.
   - Итоговое слияние `[12, 25, 34, 64]` и `[11, 22, 90]` → `[11, 12, 22, 25, 34, 64, 90]`.

---

### 2.3. Реализация через `sort.Interface`

Go предоставляет интерфейс `sort.Interface` для реализации пользовательских сортировок. Мы можем адаптировать сортировку слиянием для работы с этим интерфейсом, хотя это может быть сложнее из-за необходимости управления рекурсией и слиянием:

```go
package main

import (
    "fmt"
    "sort"
)

// IntSlice — реализация sort.Interface для среза целых чисел
type IntSlice []int

func (s IntSlice) Len() int           { return len(s) }
func (s IntSlice) Less(i, j int) bool { return s[i] < s[j] }
func (s IntSlice) Swap(i, j int)      { s[i], s[j] = s[j], s[i] }

// MergeSort — реализация сортировки слиянием через sort.Interface
func MergeSort(data sort.Interface) {
    temp := make([]int, data.Len())
    mergeSortRangeInterface(data, temp, 0, data.Len()-1)
}

func mergeSortRangeInterface(data sort.Interface, temp []int, low, high int) {
    if low < high {
        mid := (low + high) / 2
        mergeSortRangeInterface(data, temp, low, mid)
        mergeSortRangeInterface(data, temp, mid+1, high)
        mergeInterface(data, temp, low, mid, high)
    }
}

func mergeInterface(data sort.Interface, temp []int, low, mid, high int) {
    for i := low; i <= high; i++ {
        temp[i] = data.Swap(0, i) // Копируем в temp
    }

    i := low
    j := mid + 1
    k := low

    for i <= mid && j <= high {
        if temp[i] <= temp[j] {
            data.Swap(k, 0) // Вставляем temp[i]
            i++
        } else {
            data.Swap(k, 0) // Вставляем temp[j]
            j++
        }
        k++
    }

    for i <= mid {
        data.Swap(k, 0) // Вставляем оставшиеся элементы
        i++
        k++
    }
}

func main() {
    arr := []int{64, 34, 25, 12, 22, 11, 90}
    fmt.Println("Исходный массив:", arr)

    MergeSort(IntSlice(arr))
    fmt.Println("Отсортированный массив:", arr)
}
```

**Вывод:**
```
Исходный массив: [64 34 25 12 22 11 90]
Отсортированный массив: [11 12 22 25 34 64 90]
```

- Здесь сортировка слиянием адаптирована под `sort.Interface`, но требует дополнительной работы с временным массивом `temp`.

---

## 3. Преимущества сортировки слиянием

- **Высокая производительность**: Гарантированная временная сложность `O(n log n)` для всех случаев делает её предсказуемой и эффективной для больших массивов.
- **Стабильность**: Сохраняет относительный порядок одинаковых элементов, что важно для данных с несколькими полями (например, сортировка по имени, а затем по возрасту).
- **Параллелизация**: Легко адаптируется для параллельной обработки (разделение на подмассивы можно выполнять в разных горутинах).
- **Предсказуемость**: Не зависит от порядка данных в массиве, всегда работает с одинаковой скоростью.

---

## 4. Недостатки сортировки слиянием

- **Пространственная сложность**: Требует `O(n)` дополнительной памяти для временного массива при слиянии, что может быть проблемой для очень больших данных.
- **Производительность для маленьких массивов**: Меньше эффективна для небольших массивов (меньше 50 элементов) по сравнению с сортировкой вставками или Quick Sort.
- **Сложность реализации**: Более сложна для реализации и отладки по сравнению с простыми алгоритмами, такими как сортировка вставками или выбором.
- **Риск переполнения стека**: Глубокая рекурсия может привести к переполнению стека при сортировке очень больших массивов (хотя это редко).

---

## 5. Сравнение с другими алгоритмами сортировки

| Алгоритм         | Временная сложность (средняя) | Пространственная сложность | Стабильность | Применимость                 |
|-------------------|-------------------------------|----------------------------|--------------|-----------------------------|
| Слиянием (Merge) | `O(n log n)`                 | `O(n)`                     | Да           | Большие данные, стабильность |
| Быстрая (Quick)  | `O(n log n)`                 | `O(log n)` или `O(n)`      | Нет          | Большие массивы, общие случаи |
| Вставками        | `O(n²)`                      | `O(1)`                     | Да           | Небольшие, почти отсортированные массивы |
| Выбором          | `O(n²)`                      | `O(1)`                     | Нет          | Небольшие массивы, обучение |
| Пузырьковая      | `O(n²)`                      | `O(1)`                     | Да           | Небольшие, почти отсортированные массивы |
| Встроенная (`sort` в Go) | `O(n log n)`             | `O(n)`                     | Нет          | Универсальная сортировка для Go |

- В Go стандартная библиотека `sort` использует Quick Sort с оптимизациями, но Merge Sort может быть предпочтительнее, если важна стабильность или неизменная производительность.

---

## 6. Практические рекомендации

- **Используйте для больших данных**: Merge Sort подходит для массивов размером более 50-100 элементов, особенно если требуется стабильность и предсказуемость.
- **Параллелизация**: Реализуйте параллельную версию с использованием горутин для больших массивов, разделяя подмассивы между потоками:
  ```go
  func parallelMergeSort(arr []int, numWorkers int) []int {
      if len(arr) <= 1 {
          return arr
      }

      mid := len(arr) / 2
      left := make(chan []int, 1)
      right := make(chan []int, 1)

      go func() {
          left <- parallelMergeSort(arr[:mid], numWorkers/2)
      }()
      go func() {
          right <- parallelMergeSort(arr[mid:], numWorkers/2)
      }()

      return merge(<-left, <-right)
  }
  ```
- **Тестирование**: Тестируйте реализацию на различных наборах данных (отсортированных, обратных, случайных), чтобы убедиться в корректности и производительности.
- **Используйте `sort` из стандартной библиотеки**: В реальных приложениях предпочтительнее `sort.Stable` или `sort.Sort`, которые оптимизированы и поддерживают стабильность при необходимости.
- **Управление памятью**: Убедитесь, что временные массивы не приводят к чрезмерному потреблению памяти для очень больших данных, или рассмотрите потоковую обработку.

---

## 7. Заключение

Сортировка слиянием — стабильный и эффективный алгоритм с гарантированной временной сложностью `O(n log n)` для всех случаев, но требует дополнительной памяти `O(n)`. В Go её можно реализовать самостоятельно для образовательных или специфических целей, но для реальных приложений рекомендуется использовать стандартную библиотеку `sort`, которая включает оптимизации Merge Sort (`sort.Stable`) или Quick Sort. Понимание Merge Sort полезно для анализа алгоритмов, оптимизации и параллельного программирования.