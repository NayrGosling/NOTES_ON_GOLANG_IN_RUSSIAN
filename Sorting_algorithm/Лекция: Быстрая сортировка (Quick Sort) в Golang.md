# Быстрая сортировка (Quick Sort) в Golang

## Введение

Быстрая сортировка (Quick Sort) — это эффективный алгоритм сортировки, основанный на принципе "разделяй и властвуй" (divide and conquer). Он выбирает опорный элемент (pivot), разделяет массив на две части (меньшие и большие элементы относительно опоры), а затем рекурсивно сортирует эти части. Quick Sort известен своей высокой производительностью в среднем случае и широко используется в реальных приложениях.

В этой лекции мы разберём:
- Как работает быстрая сортировка.
- Реализацию алгоритма в Go.
- Преимущества и недостатки.
- Сравнение с другими алгоритмами сортировки.
- Практические примеры и рекомендации по использованию в Go.

---

## 1. Как работает быстрая сортировка?

### Принцип работы
1. **Выбор опорного элемента (pivot)**: Выбираем элемент массива в качестве опоры (обычно первый, последний или средний элемент, или случайный элемент для оптимизации).
2. **Разделение (partition)**: Перемещаем элементы так, чтобы все элементы меньше опоры оказались слева от неё, а большие — справа. Опорный элемент занимает своё окончательное положение.
3. **Рекурсия**: Рекурсивно применяем процесс к подмассивам, находящимся слева и справа от опоры, пока подмассивы не станут единичными (или отсортированными).
4. Алгоритм завершает работу, когда все элементы находятся на своих местах.

### Сложность алгоритма
- **Временная сложность**:
  - Худший случай (`O(n²)`): Когда массив уже отсортирован (или обратный порядок), и опорный элемент выбирается неудачно (например, всегда самый маленький или самый большой).
  - Лучший случай (`O(n log n)`): Когда массив случайный, и опора делит массив на равные части.
  - Средний случай (`O(n log n)`): Для случайных данных, что делает Quick Sort одним из самых эффективных алгоритмов.
- **Пространственная сложность**: `O(log n)` — для рекурсивного стека вызовов в лучшем и среднем случае; `O(n)` в худшем случае (при глубокой рекурсии).

---

## 2. Реализация быстрой сортировки в Go

### 2.1. Базовая реализация
Вот простая реализация быстрой сортировки в Go для среза целых чисел (`[]int`):

```go
package main

import "fmt"

func quickSort(arr []int) []int {
    // Создаём копию, чтобы не изменять исходный массив
    result := make([]int, len(arr))
    copy(result, arr)
    quickSortRange(result, 0, len(result)-1)
    return result
}

func quickSortRange(arr []int, low, high int) {
    if low < high {
        // Находим позицию опоры (pivot)
        pivotIdx := partition(arr, low, high)
        // Рекурсивно сортируем левую и правую части
        quickSortRange(arr, low, pivotIdx-1)
        quickSortRange(arr, pivotIdx+1, high)
    }
}

func partition(arr []int, low, high int) int {
    pivot := arr[high] // Выбираем опорный элемент (последний)
    i := low - 1       // Индекс меньших элементов

    for j := low; j < high; j++ {
        if arr[j] <= pivot {
            i++ // Увеличиваем индекс меньших элементов
            arr[i], arr[j] = arr[j], arr[i] // Меняем местами
        }
    }
    arr[i+1], arr[high] = arr[high], arr[i+1] // Размещаем опору на её место
    return i + 1
}

func main() {
    // Пример массива
    arr := []int{64, 34, 25, 12, 22, 11, 90}
    fmt.Println("Исходный массив:", arr)

    sorted := quickSort(arr)
    fmt.Println("Отсортированный массив:", sorted)
}
```

**Вывод:**
```
Исходный массив: [64 34 25 12 22 11 90]
Отсортированный массив: [11 12 22 25 34 64 90]
```

#### Разъяснение
- Функция `quickSort` создаёт копию массива и вызывает рекурсивную функцию `quickSortRange` для сортировки всего диапазона.
- `quickSortRange` рекурсивно делит массив на подмассивы, используя `partition` для размещения опоры.
- `partition` выбирает последний элемент как опору, размещает его так, чтобы все элементы меньше опоры были слева, а большие — справа, и возвращает позицию опоры.
- Опорный элемент (pivot) размещается на своём финальном месте после каждого вызова `partition`.

---

### 2.2. Пошаговый процесс для массива `[64, 34, 25, 12, 22, 11, 90]`

1. **Выбираем опору (pivot = 90)**:
   - Массив: `[64, 34, 25, 12, 22, 11, 90]`.
   - После `partition`: `[11, 12, 22, 25, 34, 64, 90]`.
   - Опорный элемент 90 перемещён на позицию 6, все меньшие элементы слева, большие — справа.
   - Теперь рекурсивно сортируем `[11, 12, 22, 25, 34, 64]` и пустой подмассив `[90]`.

2. **Рекурсия для `[11, 12, 22, 25, 34, 64]`**:
   - Выбираем новую опору (например, 64).
   - Разделяем: `[11, 12, 22, 25, 34, 64]` → `[11, 12, 22, 25, 34]` и `[64]`.
   - Продолжаем рекурсивно, пока подмассивы не станут единичными.

3. **Результат**:
   - После нескольких рекурсивных шагов массив становится `[11, 12, 22, 25, 34, 64, 90]`.

---

### 2.3. Оптимизация выбора опоры
В базовой реализации мы выбрали последний элемент как опору, что может привести к худшему случаю (`O(n²)`), если массив уже отсортирован. Для улучшения можно:
- Выбирать случайный элемент как опору.
- Использовать медиану из первых, средних и последних элементов (медиана трёх).
- Использовать вставочную сортировку для небольших подмассивов (например, длиной < 10).

#### Пример с случайной опорой
```go
package main

import (
    "fmt"
    "math/rand"
    "time"
)

func quickSort(arr []int) []int {
    result := make([]int, len(arr))
    copy(result, arr)
    quickSortRange(result, 0, len(result)-1)
    return result
}

func quickSortRange(arr []int, low, high int) {
    if low < high {
        // Выбираем случайный Pivot
        pivotIdx := low + rand.Intn(high-low+1)
        arr[pivotIdx], arr[high] = arr[high], arr[pivotIdx] // Перемещаем Pivot в конец
        pivotIdx = partition(arr, low, high)
        quickSortRange(arr, low, pivotIdx-1)
        quickSortRange(arr, pivotIdx+1, high)
    }
}

func partition(arr []int, low, high int) int {
    pivot := arr[high]
    i := low - 1

    for j := low; j < high; j++ {
        if arr[j] <= pivot {
            i++
            arr[i], arr[j] = arr[j], arr[i]
        }
    }
    arr[i+1], arr[high] = arr[high], arr[i+1]
    return i + 1
}

func main() {
    rand.Seed(time.Now().UnixNano()) // Инициализация генератора случайных чисел
    arr := []int{64, 34, 25, 12, 22, 11, 90}
    fmt.Println("Исходный массив:", arr)

    sorted := quickSort(arr)
    fmt.Println("Отсортированный массив:", sorted)
}
```

- Случайная опора уменьшает вероятность худшего случая для уже отсортированных или обратных массивов.

---

### 2.4. Реализация через `sort.Interface`

Go предоставляет интерфейс `sort.Interface` для реализации пользовательских сортировок. Мы можем адаптировать быструю сортировку для работы с этим интерфейсом:

```go
package main

import (
    "fmt"
    "sort"
)

// IntSlice — реализация sort.Interface для среза целых чисел
type IntSlice []int

func (s IntSlice) Len() int           { return len(s) }
func (s IntSlice) Less(i, j int) bool { return s[i] < s[j] }
func (s IntSlice) Swap(i, j int)      { s[i], s[j] = s[j], s[i] }

// QuickSort — реализация быстрой сортировки через sort.Interface
func QuickSort(data sort.Interface) {
    quickSortRangeInterface(data, 0, data.Len()-1)
}

func quickSortRangeInterface(data sort.Interface, low, high int) {
    if low < high {
        pivotIdx := partitionInterface(data, low, high)
        quickSortRangeInterface(data, low, pivotIdx-1)
        quickSortRangeInterface(data, pivotIdx+1, high)
    }
}

func partitionInterface(data sort.Interface, low, high int) int {
    pivot := data.Swap(0, high) // Сохраняем опору (последний элемент)
    i := low - 1

    for j := low; j < high; j++ {
        if data.Less(j, high) { // Если элемент меньше опоры
            i++
            data.Swap(i, j)
        }
    }
    data.Swap(i+1, high)
    return i + 1
}

func main() {
    arr := []int{64, 34, 25, 12, 22, 11, 90}
    fmt.Println("Исходный массив:", arr)

    QuickSort(IntSlice(arr))
    fmt.Println("Отсортированный массив:", arr)
}
```

**Вывод:**
```
Исходный массив: [64 34 25 12 22 11 90]
Отсортированный массив: [11 12 22 25 34 64 90]
```

- Здесь быстрая сортировка интегрируется с `sort.Interface`, что позволяет использовать её для любых типов, реализующих этот интерфейс.

---

## 3. Преимущества быстрой сортировки

- **Высокая производительность**: Средняя временная сложность `O(n log n)` делает её одной из самых быстрых сортировок для больших массивов.
- **Пространственная эффективность**: Требует только `O(log n)` дополнительной памяти для рекурсивного стека в среднем случае.
- **Гибкость**: Легко адаптируется для разных типов данных через интерфейсы (`sort.Interface`).
- **In-place**: Работает на месте, минимизируя использование памяти (хотя рекурсия требует стек).

---

## 4. Недостатки быстрой сортировки

- **Худший случай**: Временная сложность `O(n²)` при неудачном выборе опоры (например, если массив отсортирован или обратный, и опора всегда крайний элемент).
- **Нестабильность**: Не сохраняет относительный порядок одинаковых элементов (не является стабильной сортировкой).
- **Риск переполнения стека**: Глубокая рекурсия (в худшем случае) может вызвать переполнение стека при сортировке очень больших массивов.
- **Сложность реализации**: Более сложна для реализации и отладки по сравнению с простыми алгоритмами, такими как сортировка вставками или выбором.

---

## 5. Сравнение с другими алгоритмами сортировки

| Алгоритм         | Временная сложность (средняя) | Пространственная сложность | Стабильность | Применимость                 |
|-------------------|-------------------------------|----------------------------|--------------|-----------------------------|
| Быстрая (Quick)  | `O(n log n)`                 | `O(log n)` или `O(n)`      | Нет          | Большие массивы, общие случаи |
| Вставками        | `O(n²)`                      | `O(1)`                     | Да           | Небольшие, почти отсортированные массивы |
| Выбором          | `O(n²)`                      | `O(1)`                     | Нет          | Небольшие массивы, обучение |
| Пузырьковая      | `O(n²)`                      | `O(1)`                     | Да           | Небольшие, почти отсортированные массивы |
| Слияние (Merge)  | `O(n log n)`                 | `O(n)`                     | Да           | Стабильная сортировка, большие данные |
| Встроенная (`sort` в Go) | `O(n log n)`             | `O(n)`                     | Нет          | Универсальная сортировка для Go |

- В Go стандартная библиотека `sort` использует Quick Sort с оптимизациями (например, выбор случайной опоры и переключение на вставочную сортировку для маленьких подмассивов), что делает её предпочтительной для реальных задач.

---

## 6. Практические рекомендации

- **Оптимизация выбора опоры**: Используйте случайный Pivot или медиану трёх (первые, средний и последний элементы) для избежания худшего случая.
- **Используйте для больших данных**: Quick Sort подходит для массивов размером более 50-100 элементов, где его средняя сложность `O(n log n)` даёт значительное преимущество.
- **Переключение на вставочную сортировку**: Для подмассивов размером менее 10-20 элементов используйте сортировку вставками, так как она быстрее для маленьких данных.
- **Тестирование**: Тестируйте реализацию на различных наборах данных (отсортированных, обратных, случайных), чтобы убедиться в корректности и производительности.
- **Используйте `sort` из стандартной библиотеки**: В реальных приложениях предпочитают `sort.Sort` или `sort.Slice`, так как они оптимизированы и устойчивы к худшим случаям.

---

## 7. Заключение

Быстрая сортировка — один из самых эффективных алгоритмов сортировки в среднем случае (`O(n log n)`), но требует осторожности при выборе опоры, чтобы избежать худшего случая (`O(n²)`). В Go её можно реализовать самостоятельно для образовательных или специфических целей, но для реальных приложений рекомендуется использовать стандартную библиотеку `sort`, которая уже включает оптимизации Quick Sort. Понимание Quick Sort полезно для анализа алгоритмов, оптимизации и обучения.