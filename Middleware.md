## 1. Введение: Middleware в двух словах

**Middleware** — это "посредник" в софте. Проще говоря, это код, который стоит между запросом и ответом, обрабатывая их по пути. Если вы работали с веб-серверами, очередями или микросервисами, то уже сталкивались с middleware, даже если не называли его так.

**Пример:**
```
Клиент отправляет запрос → Middleware проверяет токен → Логика приложения → Ответ клиенту
```

### Зачем это нужно сеньору?
- **Разделение ответственности**
- **Упрощение кода**
- **Повторное использование логики**

## 2. Как устроен Middleware?
Middleware — это функция или набор функций, выполняемых в определённом порядке. Обычно это **цепочка (pipeline)**, где каждый шаг делает свою работу и передаёт управление дальше.

### Ключевые свойства:
- **Последовательность**: выполняется шаг за шагом.
- **Контекст**: доступ к данным запроса/ответа.
- **Прерывание**: может остановить цепочку (например, если аутентификация не пройдена).

#### Пример из жизни:
Представьте **конвейер** на заводе. Запрос — это деталь, а middleware — станки: один красит, другой сверлит, третий проверяет качество. Если что-то сломалось, деталь дальше не идёт.

## 3. Где используется Middleware?

| Система          | Примеры использования                     |
|-----------------|----------------------------------|
| **Веб-серверы** | Express (Node.js), ASP.NET Core, Django  |
| **API-шлюзы**   | Kong, Apigee  |
| **Очереди сообщений** | RabbitMQ, Kafka  |
| **Микросервисы** | Istio, Linkerd  |

### Сеньорский взгляд
Middleware позволяет **вынести сквозную логику** (cross-cutting concerns) из бизнес-кода, оставляя его чистым.

## 4. Пример кода (на Go)

Допустим, у нас есть HTTP-сервер. Мы хотим логировать запросы и проверять токен перед обработкой.

```go
package main

import (
	"fmt"
	"log"
	"net/http"
)

// Middleware-функция для логирования
func loggingMiddleware(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		log.Printf("Запрос: %s %s", r.Method, r.URL.Path)
		next.ServeHTTP(w, r) // Передаём дальше
	})
}

// Middleware-функция для проверки токена
func authMiddleware(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		token := r.Header.Get("Authorization")
		if token != "secret-token" {
			http.Error(w, "Нет доступа", http.StatusUnauthorized)
			return // Прерываем цепочку
		}
		next.ServeHTTP(w, r) // Токен ок, идём дальше
	})
}

// Основной обработчик
func handler(w http.ResponseWriter, r *http.Request) {
	fmt.Fprintf(w, "Привет, ты прошёл проверку!")
}

func main() {
	mux := http.NewServeMux()
	mux.HandleFunc("/", handler)

	// Собираем цепочку middleware
	finalHandler := loggingMiddleware(authMiddleware(mux))

	log.Fatal(http.ListenAndServe(":8080", finalHandler))
}
```

### Что здесь происходит?
1. `loggingMiddleware` — логирует каждый запрос.
2. `authMiddleware` — проверяет токен. Если он неверный, возвращает 401 и прерывает цепочку.
3. Если всё ок, запрос доходит до `handler`.

## 5. Почему это важно для сеньоров?

### **Разделение ответственности**
Бизнес-логика отдельно, сквозная логика (логи, метрики, авторизация) — в middleware.

### **Повторное использование**
Написали middleware для логов? Используйте его везде.

### **Гибкость**
Хотите добавить сжатие ответов? Просто пишете новый middleware, не трогая старый код.

### **Диагностика и отладка**
Middleware — идеальное место для трассировки и мониторинга.

## 6. Типичные задачи Middleware
- **Аутентификация/авторизация**: Проверка токенов, ролей.
- **Логирование**: Запись запросов, ошибок.
- **Обработка ошибок**: Перехват паник, возврат 500 вместо краша.
- **Кэширование**: Сохранение частых ответов.
- **Rate limiting**: Ограничение числа запросов.
- **Преобразование данных**: Например, сжатие JSON в Gzip.

## 7. Проблемы и их решения

| Проблема | Решение |
|----------|---------|
| **Порядок выполнения**: если логи после авторизации, неуспешные запросы не залогируются. | Логи идут первыми, авторизация — следом. |
| **Производительность**: слишком много middleware замедляет запросы. | Оптимизируйте, убирайте лишнее, профилируйте. |
| **Сложность отладки**: ошибка где-то в цепочке. | Добавьте логи или трассировку (OpenTelemetry). |

### Сеньорский подход
Тестируйте **каждый middleware отдельно**, чтобы цепочка не стала "чёрным ящиком".

## 8. Реальный кейс

Допустим, вам нужно сделать API для магазина. Middleware может:

- Логировать все запросы (`GET /products`).
- Проверять JWT-токен для доступа к `/orders`.
- Кэшировать популярные товары в `/products/popular`.
- Ограничивать запросы на `/checkout` до 10 в минуту на IP.

С такой цепочкой бизнес-логика остаётся простой: **"верни товары", "создай заказ"**. Всё остальное — в middleware.

## 9. Заключение

**Middleware** — это ваш лучший друг для **масштабируемого и поддерживаемого кода**. Оно берёт на себя рутину, оставляя бизнес-логику чистой и понятной.

### **Как использовать правильно?**
✅ Не перебарщивайте с количеством слоёв.
✅ Держите порядок в цепочке.
✅ Тестируйте middleware отдельно.


